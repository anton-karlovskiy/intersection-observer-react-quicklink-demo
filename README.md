## Integration example

### Get started

```js
$ npm i
$ npm run build && npm run serve
```

### Methodology

The core challenge with getting Quicklink to work with a single-page application
architecture is that fetches for routes (e.g `/article`, '`/blog` etc.) do not 
fetch the JavaScript chunks these routes correspond to (i.e `2.chunk.js`). 

Another challenge is that JS chunks generated by a modern module bundler typically 
also use long-term hashing for versioning (`2.chunk.46e51.js`), meaning that you can't just manually prefetch these URLs given they lack determinism.  

A solution to this problem is to create a manifest of all the resources corresponding
to any given route so that they can be prefetched as needed. 

This project uses [webpack-route-manifest](https://github.com/lukeed/webpack-route-manifest) to generate an asset manifest file, keyed by route patterns.
This provides us knowledge of exactly which files are going to be requested for each route of the application, enabling solutions like Quicklink to prefetch them.

```js
		new RouteManifest({
			minify: true,
			filename: 'rmanifest.json',
			routes(str) {
				let out = str.replace('@pages', '').toLowerCase();
				if (out === '/article') return '/blog/:title';
				if (out === '/home') return '/';
				return out;
			}
        });
```

The output of the rmanifest.json file for a single-page app looks like the following:

```js
{"/":[{"type":"style","href":"/1.chunk.4b8ee.css"},{"type":"script","href":"/1.chunk.e9ba3.js"},{"type":"image","href":"/b9b6e9e1395d2474ac56b843a0623f56.svg"}],"/blog":[{"type":"style","href":"/2.chunk.dd487.css"},{"type":"script","href":"/2.chunk.46e51.js"}],"/about":[{"type":"style","href":"/3.chunk.49e2d.css"},{"type":"script","href":"/3.chunk.f59b8.js"}],"/blog/:title":[{"type":"style","href":"/4.chunk.b5922.css"},{"type":"script","href":"/4.chunk.b144d.js"}],"*":[{"type":"style","href":"/bundle.2fc6c.css"},{"type":"script","href":"/bundle.15ef05a9.js"},
```

As you will notice, entries are included for JavaScript chunks with their long-term hashes as well as other resources like stylesheets.

A Quicklink component (see src/components/Quicklink) uses both a small runtime library for reading the route-manifest
and a small wrapper for prefetching these files:

```js
import { findDOMNode } from 'react-dom';
import { createElement, useEffect, useRef } from 'react';
import { prefetch, listen } from 'quicklink';
import rmanifest from 'route-manifest';

const wrappers = new Set();

function fetchWithAssets(href) {
	prefetch(href).then(() => {
		if (window._rmanifest_) {
			const entry = rmanifest(window._rmanifest_, href);
			const files = entry.files.map(x => x.href);
			if (files.length) prefetch(files);
		}
	});
}

// TODO?: add `options` param here
export function QLink(Component) {
	return function (props) {
		const href = props.to || props.href;
		if (href) {
			console.log('Qlink will prefetch', href);
			fetchWithAssets(href);
		}
		return createElement(Component, props);
	}
}

// TODO?: add `options` param here
export function QRoute(Component) {
	return function (props) {
		const { component, ...rest } = props;
		if (component) rest.component = QRoute(component);
		const ref = rest.ref = useRef(null);

		useEffect(() => {
			console.log('I heard route change~!');

			// find the route's DOM ref
			let elem = findDOMNode(ref.current);
			if (elem) {
				// Does this have <a> tags? If not (eg, loader) move up
				if (elem.nodeType !== 1 || !elem.querySelector('a')) {
					elem = elem.parentElement;
				}

				if (wrappers.has(elem)) {
					console.log('QRoute is already watching', elem);
				} else {
					console.log('QRoute will run `quicklink` on', elem);
					listen({ el: elem });
					wrappers.add(elem);
				}
			}

			// todo: unlisten
			return () => {
				console.log('QRoute is releasing', elem);
				wrappers.delete(elem);
			}
		}, [ref]);

		return createElement(Component, rest);
	};
}
```

## Credits

With special thanks to Luke Edwards for his research into this problem space
for Quicklink and creation of route-manifest.